
import numpy as np
import matplotlib.pyplot as plt
import robotransforms.euclidean.euclidean_pure as t
import robotransforms.utils.utils as rt_utils

## ======================
## CODE
## ======================
def DeadReckonStep(timestamp, dl, dr, Dq): #, vave, vdiff):
    return np.array([ timestamp, dl, dr, Dq[0], Dq[1], Dq[2], Dq[3]]) #, vave, vdiff ])

L_PLUS_LAMBDA = 3

def sinc(x):
    # Use power series for small x
    if (np.abs(x) < 1e-4): return 1 - (x*x/6) + (x*x*x*x/120)
    return np.sin(x)/x

D = 0.5
def dead_reckon_step( quat, dl, dr): #, vave, vdiff ):
    lstar = 0.5 * ( dl + dr )
    to2 = ( dl - dr ) / ( 2 * D )
    chord = lstar * sinc(to2)
    sin = np.sin(to2)
    cos = np.cos(to2)

    dx = chord * sin
    dy = chord * cos

    return t.apply_quat(t.invert_quat(quat), [dx,dy,0])

def dead_reckon_step_errors( dl, dr, dl_scale=0.005): #vave, vdiff, dl_scale=0.005):
    ddl = (dl_scale * np.abs(dl))
    ddr = (dl_scale * np.abs(dr))
    rho=1-1e-3
    #rho = 1-1e-8
    #if ( np.abs(vdiff) >= 1e-3 ) :
    #    rho = np.abs(np.tanh( vave / vdiff ))

    #  [ var_dl, cov_dldr, var_dr, var_b, var_c, var_d ]
    return [ ddl*ddl + 1e-8, rho*ddl*ddr, ddr*ddr + 1e-8 ] # TODO : these are estimates, based on gps's 1Hz

def jacobian_quat_position(quat, dl, dr):
    """
    Compute the Jacobian of the position component with respect to the quaternion
    for a given wheel odometry measurement (dl, dr).

    Parameters:
    quat (numpy array): Quaternion representing the rotation.
    dl (float): Left wheel displacement.
    dr (float): Right wheel displacement.

    Returns:
    numpy array: The 3x3 Jacobian matrix.
    """

    qw, qx, qy, qz = quat

    J = np.array([
        [2 * qw * dr - 2 * qy * dl, 2 * qx * dr + 2 * qz * dl, -2 * qz * dr + 2 * qx * dl, -2 * qy * dr - 2 * qw * dl],
        [2 * qy * dr + 2 * qw * dl, -2 * qx * dr + 2 * qz * dl, 2 * qw * dr + 2 * qy * dl, 2 * qz * dr + 2 * qx * dl],
        [-2 * qx * dl - 2 * qz * dr, -2 * qy * dl + 2 * qw * dr, 0, 0]
    ])

    return J


def dead_reckon_apply(x_hat, P_hat, step):

    # Generate sigma points
    Z = sigma_points(x_hat, P_hat, alpha, beta, kappa)
    SS = len(x_hat)

    # Transform to new vectors
    def T(_z):
        # Apply transformation for each sigma point
        d_wheels = np.array([_z[SS+0], _z[SS+1]])
        quat = t.redquat2quat([0, 0, _z[2]])
        _new_pos = t.transform_quat_position(quat, d_wheels)
        return np.hstack([_z[:SS] + _new_pos, _z[SS+2:]])

    Y = np.array([T(_z) for _z in Z])

    # Calculate the Jacobian of the transformation
    def dT_dq(_z):
        quat = t.redquat2quat([0, 0, _z[2]])
        return jacobian_quat_position(quat, _z[SS+0], _z[SS+1])

    J_quat = np.array([dT_dq(_z) for _z in Z])

    y_pos_bar = W0 * Y[0][:SS] + W * Y[1:2 * SS].sum(axis=0)
    Y_pos = Y[:, :SS]
    Z_pos = Z[:, :SS]
    e_quats = Z[:, 2:3] - y_pos_bar[2]

    e_rquats = t.redquats2rquats(e_quats)
    dY = np.hstack([Y_pos - y_pos_bar, e_rquats[:, 2:]])
    dY_quat = np.hstack([Y_pos - y_pos_bar, e_rquats])

    cov = W0 * np.array([dY[0]]).T @ np.array([dY[0]])
    cov_quat = W0 * np.array([dY_quat[0]]).T @ J_quat[0] @ np.array([dY_quat[0]])

    for k in range(1, len(dY)):
        cov = cov + W * np.array([dY[k]]).T @ np.array([dY[k]])
        cov_quat += W * np.array([dY_quat[k]]).T @ J_quat[k] @ np.array([dY_quat[k]])

    # Add the quaternion-related covariance to the position-related covariance
    cov[:2, :2] += cov_quat[:2, :2]

    x_tilde = T(x_hat)
    P_tilde = cov

    return x_tilde, P_tilde

def dead_reckon(x_hat, P_hat, steps):
    for step in steps:
        x_hat, P_hat = dead_reckon_apply(x_hat, P_hat, step)
    return x_hat, P_hat

## ======================
## test
## ======================

D = 0.464
dl = 0.08
dr = 0.07
to2 = ( dl - dr ) / ( 2 * D )

x_hat = np.array([0,0,0])
P_hat = np.diag([1e-1,1e-1,0.05])
step = np.array([
    43994.76,          # ts
    dl, dr,      # dl, dr
    np.cos(to2), 0, 0, -np.sin(to2),    # Dq: a,b,c,d
    #0.215, 0.143,     # vave, vdiff
])
steps = 3*[step]


xhs = [x_hat]
phs = [P_hat]

for i in range(50):
    print("==================================== "+str(i+1))
    x_hat, P_hat = dead_reckon(x_hat, P_hat, steps)
    xhs.append(x_hat)
    phs.append(P_hat)

    v,w = np.linalg.eigh(P_hat)
    print("v")
    print(",".join("{:12.8f}".format(v) for v in v))
    print()
    print("W")
    for row in w:
        print(",".join("{:12.8f}".format(v) for v in row))
    print()

print("x")
print(",".join("{:12.8f}".format(v) for v in x_hat))
print()
print("P")
for row in P_hat:
    print(",".join("{:12.8f}".format(v) for v in row))
print()


fig = plt.figure()
ax = fig.add_subplot(111)

for x,p in zip(xhs, phs):
    L = np.linalg.cholesky(p)[:2,:2]
    xy = np.array([L@np.array([np.sin(u), np.cos(u)]) + x[:2] for u in np.linspace(0,2*np.pi,100)])
    plt.plot(x[:1], x[1:2], "x")
    plt.plot(xy[:,0], xy[:,1])


plt.show()

